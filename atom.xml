<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>InfiniteX</title>
  
  <subtitle>Code Life Easy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://infinitexyy.github.io/"/>
  <updated>2019-04-02T04:19:09.990Z</updated>
  <id>https://infinitexyy.github.io/</id>
  
  <author>
    <name>Yiyang Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>realm-learn</title>
    <link href="https://infinitexyy.github.io/2019/04/02/realm-learn/"/>
    <id>https://infinitexyy.github.io/2019/04/02/realm-learn/</id>
    <published>2019-04-02T04:18:21.000Z</published>
    <updated>2019-04-02T04:19:09.990Z</updated>
    
    <content type="html"><![CDATA[<p>这是自己以前总结的一篇关于Realm使用的文章<br><a id="more"></a></p><h1 id="Realm-Learn"><a href="#Realm-Learn" class="headerlink" title="Realm Learn"></a>Realm Learn</h1><p>base on realm 2.13.0</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>in <code>javascript</code>, <em>Table schema</em> in <strong>Realm</strong> is an <strong>object</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//schema of studnet</span></span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    name: <span class="string">"Student"</span> <span class="comment">// Required: Table name,</span></span><br><span class="line">    primaryKey: <span class="string">"id"</span>, <span class="comment">// Optional</span></span><br><span class="line">    properties: &#123;</span><br><span class="line">    id: &#123;<span class="attr">type</span>: <span class="string">"int"</span>&#125;</span><br><span class="line">    student_name: &#123; <span class="attr">type</span>: <span class="string">"string"</span> &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Property-object"><a href="#Property-object" class="headerlink" title="Property object:"></a>Property object:</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = &#123;</span><br><span class="line">    <span class="comment">// int, bool, string, float, double, date, data,</span></span><br><span class="line">    type: <span class="string">"string"</span>, <span class="comment">// Required</span></span><br><span class="line">    optional: <span class="literal">false</span>, <span class="comment">// Optional, if true, property can be null/undefined,</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="string">"noname"</span>, <span class="comment">// Optional</span></span><br><span class="line">    index: <span class="literal">true</span> <span class="comment">// Optional, only support int, string, bool, date</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List property can be defined as <code>int[]</code> or <code>string?[]</code></p><p>notice that list property can’t assgined null.</p><h6 id="syntactic-sugar"><a href="#syntactic-sugar" class="headerlink" title="syntactic sugar:"></a>syntactic sugar:</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">properties = &#123;</span><br><span class="line">    name: <span class="string">"string"</span>,</span><br><span class="line">    scores: <span class="string">"int[]"</span>,</span><br><span class="line">    avatar: <span class="string">"data?"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="relation"><a href="#relation" class="headerlink" title="relation"></a>relation</h2><h4 id="To-one"><a href="#To-one" class="headerlink" title="To-one"></a>To-one</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">properties = &#123;</span><br><span class="line">    owenr: <span class="string">"Person"</span> <span class="comment">// just use another table name as the type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>make sure all the tables included are opened by Realm</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// its quite easy to access realted object</span></span><br><span class="line">dog.owner.age += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="To-many"><a href="#To-many" class="headerlink" title="To-many"></a>To-many</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">properties = &#123;</span><br><span class="line">    tasks: <span class="string">"Homework[]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add new task</span></span><br><span class="line"><span class="keyword">let</span> anotherTask = &#123;<span class="attr">content</span>: <span class="string">""</span>, <span class="attr">createTime</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span><br><span class="line">course.tasks.push(anotherTask)</span><br><span class="line"><span class="comment">// get task</span></span><br><span class="line"><span class="keyword">let</span> taskOne = course.tasks[<span class="number">0</span>].model</span><br></pre></td></tr></table></figure><h4 id="Inverse"><a href="#Inverse" class="headerlink" title="Inverse"></a>Inverse</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.properties.dogs = "Dog[]"</span></span><br><span class="line">owners: &#123;<span class="attr">type</span>: <span class="string">'linkingObjects'</span>, <span class="attr">objectType</span>: <span class="string">'Person'</span>, <span class="attr">property</span>: <span class="string">'dogs'</span>&#125;</span><br><span class="line"><span class="comment">// Homework.properties.course = "Course"</span></span><br><span class="line">homeworkList: &#123;<span class="attr">type</span>: <span class="string">'linkingObjects'</span>, <span class="attr">objectType</span>: <span class="string">'Homework'</span>, <span class="attr">property</span>: <span class="string">'course'</span>&#125;</span><br></pre></td></tr></table></figure><p>First it’s a <strong>many-many</strong> relation: </p><blockquote><p><em>many dogs to many owners</em></p></blockquote><p>access by <code>dog.owners</code></p><p>Second it’s a <strong>one-many </strong>relation</p><blockquote><p><em>many homework to one course</em></p></blockquote><p>access by <code>course.homeworkList</code></p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p><strong>In order to chang data in the database, you have to use <code>write()</code> method first.</strong></p><p><strong>Use minimum numbers of  <code>write</code>  block</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dogSchema = &#123;</span><br><span class="line">    name: <span class="string">"Dog"</span>,</span><br><span class="line">    properties: &#123;</span><br><span class="line">        age: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// try catch is not required</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ... <span class="comment">// CUD</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Error on write()"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> myDog = realm.create(<span class="string">'Dog'</span>, &#123;<span class="attr">age</span>: <span class="number">4</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><h6 id="query-method"><a href="#query-method" class="headerlink" title="query method"></a>query method</h6><ul><li>filtered<ul><li>comparison operators  ( &gt;, &lt;, &lt;=, ==, !=. )</li><li>String (CONTAINS, BEGINWITH, ENDWITH, LIKE)</li><li>AND, OR</li><li>aggregate expression(.@size, .@min, .@max, .@avg)</li></ul></li><li>sorted<ul><li>name DESC, age ASC (DESC is <code>true</code> as the second param)</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldDogs = realm.objects(<span class="string">'Dog'</span>).filtered(<span class="string">'age &gt; 100'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oldDogs = realm.objects(<span class="string">'Dog'</span>).sorted([[<span class="string">'age'</span>, <span class="literal">true</span>], [<span class="string">'name'</span>, <span class="literal">false</span>]])</span><br></pre></td></tr></table></figure><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h6><ul><li>results are auto-updated</li></ul><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    myDog.age += <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">realm.write(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    realm.delete(myDog)</span><br><span class="line">    realm.deleta(oldDogs) <span class="comment">// can delect object list</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="open-close"><a href="#open-close" class="headerlink" title="open/close"></a>open/close</h2><h6 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Realm.open(&#123;Configuration&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">realm</span> =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="Synchromnously-open"><a href="#Synchromnously-open" class="headerlink" title="Synchromnously open"></a>Synchromnously open</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> realm = <span class="keyword">new</span> Realm(&#123;options&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration:"></a>Configuration:</h4><ul><li><p><code>schema</code> : <strong>Required</strong></p></li><li><p><code>schemaVersion</code> : <strong>Required</strong> if realm did exist</p><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to get current version</span></span><br><span class="line"><span class="keyword">const</span> v = Realm.schemaVersion(Realm.defaultPath);</span><br><span class="line"><span class="keyword">let</span> nextVersion = v + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>migaration</code> : update database schema, keep original data</p></li><li><p><code>deleteRealmIfMigrationNeeded</code> : for development.</p></li><li><p><code>path</code> : will use default path if not specified</p></li><li><p><code>sync</code> : open a synchronized Realm on the serverside</p><p>…</p></li></ul><h2 id="Listeners"><a href="#Listeners" class="headerlink" title="Listeners"></a>Listeners</h2><blockquote><p>Realm instances send out notifications to other instances <strong>every time a write transaction is committed</strong>.</p></blockquote><p>All the <strong>List, Results, Realm</strong> provides <code>addListenr</code> Method</p><h6 id="Realm-Notifications-realm-addListener"><a href="#Realm-Notifications-realm-addListener" class="headerlink" title="Realm Notifications (realm.addListener)"></a>Realm Notifications (realm.addListener)</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observe Realm Notifications</span></span><br><span class="line">realm.addListener(<span class="string">'change'</span>, updateUI);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..later remove the listener</span></span><br><span class="line">realm.removeListener(<span class="string">'change'</span>, updateUI);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..or unregister all listeners</span></span><br><span class="line">realm.removeAllListeners();</span><br></pre></td></tr></table></figure><h6 id="Collection-Notifications"><a href="#Collection-Notifications" class="headerlink" title="Collection Notifications"></a>Collection Notifications</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是自己以前总结的一篇关于Realm使用的文章&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题（四）图</title>
    <link href="https://infinitexyy.github.io/2019/03/30/leetcode-graph/"/>
    <id>https://infinitexyy.github.io/2019/03/30/leetcode-graph/</id>
    <published>2019-03-30T14:51:15.000Z</published>
    <updated>2019-03-30T14:54:47.124Z</updated>
    
    <content type="html"><![CDATA[<p>要解决图的问题，基本上无非是通过DFS、BFS来遍历，使用DP原则来优化算法。因此，图是一个综合性极强的题目类型。</p><a id="more"></a><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h3 id="拓扑序"><a href="#拓扑序" class="headerlink" title="拓扑序"></a>拓扑序</h3><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h3 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a>缩点</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要解决图的问题，基本上无非是通过DFS、BFS来遍历，使用DP原则来优化算法。因此，图是一个综合性极强的题目类型。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题（三）树</title>
    <link href="https://infinitexyy.github.io/2019/03/27/leetcode-tree/"/>
    <id>https://infinitexyy.github.io/2019/03/27/leetcode-tree/</id>
    <published>2019-03-27T02:24:07.000Z</published>
    <updated>2019-03-30T14:50:59.122Z</updated>
    
    <content type="html"><![CDATA[<p>树的题目实现起来比较简单（通常使用递归），难的是如何根据题目意思找到合适的递推函数，将大的问题一点点变小。以下列举了一些在刷题过程中遇到的树的类型。</p><a id="more"></a><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>分为三种遍历，前中后序。即根节点出现在式子的前面、中间、最后。如果用递归实现就比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 0</span></span><br><span class="line">  helper(t.left);</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  result.add(t.val);</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  helper(t.right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个中序遍历，前后序遍历同理。</p><p>如果使用迭代的话，考虑到递归就是一个运行栈，因此这里也可以使用栈的方式来<strong>模拟</strong>递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">  <span class="comment">// 0</span></span><br><span class="line">  <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stack.push(cur);</span><br><span class="line">    cur = cur.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  cur = s.pop();</span><br><span class="line">  result.add(cur.val);</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  cur = cur.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其基本思想与递归是一致的。</p><p>首先把所有左边的内容加入栈(进入递归函数)。</p><p>然后从最后加入的元素开始，逐个弹出</p><p>另外还有一种个题目，是对两个树进行比较。同样可以将大问题变小。比如两棵树相同意味着，它们根节点相同，且左右子树都相同。在此不再多说。</p><h3 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h3><p>与遍历采取的方法相同，可能有以下几种类型</p><ul><li><p>求深度(上下、左右)</p><p>通过递归(每次dfs深度+1)的思想来简化计算。</p></li><li><p>收集数字</p><p>可以使用额外的类来记录每个节点的深度、或者使用递归的方式来记录深度。</p></li></ul><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>核心在于，删除某些节点也是递推的。从根节点开始删，等于从子树删完，然后再与根节点相连接。</p><p>于是问题就简化为对某个节点内容的判断，之后靠返回值再慢慢拼接起来就可以了。</p><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树的题目实现起来比较简单（通常使用递归），难的是如何根据题目意思找到合适的递推函数，将大的问题一点点变小。以下列举了一些在刷题过程中遇到的树的类型。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS基础知识</title>
    <link href="https://infinitexyy.github.io/2019/03/20/JS-learn/"/>
    <id>https://infinitexyy.github.io/2019/03/20/JS-learn/</id>
    <published>2019-03-20T05:05:28.000Z</published>
    <updated>2019-03-24T08:15:51.411Z</updated>
    
    <content type="html"><![CDATA[<p>整理了一下自己不熟悉的几个点</p><a id="more"></a><ul><li>数据类型</li><li>基本语法、控制流</li><li>函数</li><li>面向对象</li><li>错误处理</li><li>单线程</li><li>测试</li><li>ES6/ES7</li><li>其它</li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><code>typeof</code>：判断基本数据类型(<code>null</code>也是<code>object</code>)</p><p><strong><code>instanceof</code>：判断具体是哪种对象</strong></p><p><code>number</code> <code>object</code> <code>string</code> <code>boolean</code> <code>undefined</code> <code>null</code> <code>symbol</code></p><ul><li>unicode、utf-8</li><li><code>in</code>操作符与<code>hasOwnProperty</code></li><li>Map、Set</li><li>解构：默认值，多层解构，swap</li></ul><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><ul><li><code>interable</code>, <code>forEach</code>, <code>for...of...</code></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li>变量作用域，var互不影响、从内而外</li><li>变量提升(可以访问，但是是<code>undefined</code>)</li><li>window全局作用域(Nodejs是global)</li><li><code>this</code>与strict mode 与<strong>执行栈</strong> <a href="https://www.zhihu.com/search?type=content&amp;q=%E6%89%A7%E8%A1%8C%E6%A0%88" target="_blank" rel="noopener">知乎</a><ul><li>this绑定(对象或全局)</li><li>词法环境(变量映射、外部此法环境的引用)<ul><li>全局环境</li><li>函数环境(arguments对象）</li><li>变量环境(属于词法环境，经用于存储<code>var</code>的绑定)</li></ul></li></ul></li><li>apply/call(参数的不同)<a href="https://github.com/lin-xin/blog/issues/7" target="_blank" rel="noopener">github</a></li><li>箭头函数的词法作用域</li><li>生成器(yield) 与 ajax</li><li>闭包：函数与函数中的变量 <a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="noopener">知乎</a><ul><li>如何实现？堆</li></ul></li></ul><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul><li>基本对象Date/Reg/JSON<ul><li>Date在JS中月份从0开始</li><li>Reg用于split很方便</li><li>Reg还可以用来分组(使用括号)</li><li>JSON.stringfy(object, replacer, space)</li></ul></li><li>this，与运行上下文</li><li>原型链，一个对象的原型指向另一个对象</li><li>为原型增加方法，使用prototype</li><li>prototype vs <code>__proto__</code> <a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">知乎</a><ul><li>prototype是函数特有的对象，它只有一个属性constructor，它的内容是函数自身</li><li>proto指向构造它的函数的prototype</li></ul></li><li>class</li></ul><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><ul><li>try catch finally<ul><li>finally中的内容即使return依然会运行到</li></ul></li><li>若抛出错误，会一直向上寻找catch，直到JavaScript引擎</li><li>异步操作需要在回调函数中捕获异常</li></ul><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><ul><li>JavaScript是单线程的</li><li>使用异步回调来增加异步任务的性能</li><li>Event Loop<ul><li>执行栈 + 任务队列，当栈空的时候会去读取任务队列。</li></ul></li><li>Nodejs的<code>process.nextTick</code><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">阮一峰</a></li><li><p>Web Worker(Html5的多线程，作为主线程的子线程)</p><ul><li>执行的脚本必须来自网络</li><li>通信必须通过消息(postMessage发送，onmessage接收)</li><li>不能使用主线程的DOM对象<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4></li></ul></li><li><p>mocha</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"#function1()"</span>, () =&gt; &#123;</span><br><span class="line">  before(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  it(<span class="string">"... should ..."</span>, () =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  it(<span class="string">"... should ..."</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><ul><li><p>Set, Map</p></li><li><p>let</p></li><li><p>const</p></li><li><p>for … of …</p></li><li><p>解构</p></li><li><p>箭头函数</p></li><li><p>yield</p></li><li><p>class继承(取代原来原型链的复杂方法)</p></li><li><p>Promise</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (something) &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>Canvas</li><li>import</li></ul><h4 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h4><ul><li>async await</li></ul><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><ul><li>模块<ul><li>module.exports与exports(后者只是前者最初的一个引用，最后看的还是module.exports,好苦逼啊)<a href="https://juejin.im/post/597ec55a51882556a234fcef" target="_blank" rel="noopener">掘金</a></li><li>模块的原理(闭包)</li></ul></li><li>Fs(readFile, readFileSync)</li><li>stream</li><li>crypto(md5、AES、RSA……)</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li>短路运算符 a || b (if a is null then b else a) a &amp;&amp; b (if a is null then null, else b)</li><li><code>window</code> <code>navigator</code> <code>location</code> <code>screen</code><ul><li>history</li><li>Document<ul><li>appendChild, insertBefore</li></ul></li></ul></li><li>表单<ul><li>onsubmit 返回值</li><li>Type submit reset</li><li>input hidden,没有name属性的不会被提交</li></ul></li><li>AJAX与CORS<ul><li>代理</li><li>Flash</li><li>JSONP(函数回调的方式，利用了js跨域脚本)</li><li>CORS<ul><li>简单请求(GET、不使用JSON的POST)<code>Access-Control-Allow-Origin</code></li><li>发送<code>OPTIONS</code>请求，询问是否可以接受某种类型的请求</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理了一下自己不熟悉的几个点&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题（二）动态规划</title>
    <link href="https://infinitexyy.github.io/2019/03/18/leetcode-dp/"/>
    <id>https://infinitexyy.github.io/2019/03/18/leetcode-dp/</id>
    <published>2019-03-18T15:32:10.000Z</published>
    <updated>2019-03-24T09:18:53.075Z</updated>
    
    <content type="html"><![CDATA[<p><strong>动态规划简介</strong></p><p>虽然动态规划这名字听起来挺玄乎的，但在我看来，动态规划无非是在暴力搜索下的一种优化算法罢了。核心是<strong>减少重复性</strong>的运算。如何减少重复性运算呢？</p><a id="more"></a><p>DP的做法是维持一个状态数组，用来换数据。在此上，我认为DP有四个部分最为重要</p><ul><li>状态数组是什么</li><li>状态数组是怎么初始化的</li><li>状态是如何迁移的(怎么根据上一个状态获得新的状态从而达到缓存的目的)</li><li>如何从状态数组获得结果</li></ul><p>对于斐波那契数列而言</p><p><strong>状态数组：</strong>数列中的每个数字</p><p><strong>初始化：</strong>dp[0] = dp[1] = 1</p><p><strong>迁移：</strong>dp[n] = dp[n-1] + dp[n-2]</p><p><strong>结果：</strong>return dp[n]</p><p>另外dp写法又有自顶而下，自下而上两种，我的理解是递归和循环。我个人偏向递归，因为有种：我要知道a的话就要先知道b的递推感。</p><p>参考leetcode上<a href="https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems." target="_blank" rel="noopener">一篇文章</a>，解法可以有以下步骤</p><ol><li>找到递推关系</li><li>递归实现 (top-down)</li><li>递归实现 + 记忆数组 (top-down)(QWQ我个人停留在这里)</li><li>迭代 + 记忆数组 (bottom-up)</li><li>Iterative + N variables (bottom-up)(例如斐波那契数列只需要知道n-1、n-2两个数)</li></ol><h3 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h3><p>最大上升子序列、最大子序列和等等。这类问题要先想清楚，如何对小的答案进行扩展，例如，我知道了前n个数字的答案，怎么通过这个答案求出第n+1个数呢？也就是状态转移方程，知道了这个就不难了。</p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><p><em>2018-3-19</em><br>更新”动态规划简介”部分</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;动态规划简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然动态规划这名字听起来挺玄乎的，但在我看来，动态规划无非是在暴力搜索下的一种优化算法罢了。核心是&lt;strong&gt;减少重复性&lt;/strong&gt;的运算。如何减少重复性运算呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题（一）搜索</title>
    <link href="https://infinitexyy.github.io/2019/03/16/leetcode-search/"/>
    <id>https://infinitexyy.github.io/2019/03/16/leetcode-search/</id>
    <published>2019-03-16T12:10:21.000Z</published>
    <updated>2019-03-23T08:52:54.780Z</updated>
    
    <content type="html"><![CDATA[<p>当重复一件事情多次以后，自然而然地就能找到其中的规律。于是我打算按照以下规则来做题，希望能够事半功倍吧。</p><a id="more"></a><ol><li>优先完成相似题目</li><li>从Easy的题目开始</li><li>思考过后仍做不出来就看答案</li><li>对于曾看答案的题目，要重复做</li><li>做完相似题目，对其归纳总结</li></ol><p>注1：这些方法来自于<a href="https://www.youtube.com/channel/UC5xDNEcvb1vgw3lE21Ack2Q" target="_blank" rel="noopener">花花酱</a>的一期视频，相似题目来自于<a href="https://bit.ly/2E8yBHq" target="_blank" rel="noopener">LeetCode 题目分类</a>(感谢huahua)，大家可以参考了刷题~</p><p>注2：这篇博客只是一份个人笔记，如有错误，还请指出啦，谢谢~</p><h3 id="搜索简介"><a href="#搜索简介" class="headerlink" title="搜索简介"></a>搜索简介</h3><p>搜索即遍历所有情况，找到正确答案。在很多情况下，搜索又被称作暴力算法。</p><p>它们都有以下特征：</p><ul><li>需要枚举<strong>所有的情况</strong></li><li>有一个<strong>判断是否为解</strong>的方法</li></ul><p>下面将从几个具体的类型，来介绍如何使用暴力搜索。这些类型分别对应<a href="https://bit.ly/2E8yBHq" target="_blank" rel="noopener">LeetCode 题目分类</a>，Search页内的题目。</p><h5 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h5><p>回溯是暴力搜索常用的算法，在暴力搜索中，回溯通常有以下步骤：</p><ol><li>判断该数组是否为解(若为解则退出)</li><li>将某个元素放到数组</li><li>递归(使用该数组)</li><li>将当前内容弹出</li></ol><p>这样就可以遍历所有的情况了。</p><h3 id="组合-conbination"><a href="#组合-conbination" class="headerlink" title="组合(conbination)"></a>组合(conbination)</h3><p>这类题通常要求将一些选项<strong>组合</strong>，选择出可行的解。例如：3个不同的数字组合为9的方法……对这类问题，可以使用<strong>回溯</strong>的方法。</p><p>例如<code>求幂集</code>这道题，其递归伪代码表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">ans = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">curList, from</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不需要判断，全部都可以加入</span></span><br><span class="line">  ans.add(curList.clone())</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">from</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    curList.push(nums[i]);</span><br><span class="line">    <span class="comment">// 2 (这里每次将起始点加1，这样就可以保证不重复)</span></span><br><span class="line">    backtrack(curList, i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    curList.remove(curList.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips：如果输入数组有重复的元素，且要求解集不能有重复，可以先对候选数字排序，然后，加入以下判断语句来过滤掉重复的解，来保证独立性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除去第一次，后面数字的如果跟前面的一样，那直接pass</span></span><br><span class="line"><span class="comment">// 对于一串一样的数字，只要选第一个就可以了</span></span><br><span class="line"><span class="keyword">if</span> (i != from &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="排列-permutation"><a href="#排列-permutation" class="headerlink" title="排列(permutation)"></a>排列(permutation)</h3><p>这类题通常要求将输入数组<strong>排列</strong>，获得正确的解（即不同的顺序是不一样的）。它与组合问题区别在于，每一次都需要从0开始遍历数组，因此为了防止元素重复使用，往往会额外使用一个used数组，来记录每一个数字的使用情况。这类暴力求解的复杂度通常是<code>n!</code>，因此如果看到<code>1 &lt;= A.length &lt;= 10</code>的Note，可以考虑暴力算法，更大的话，性能会太差。</p><p>例如：给你一个集合，让你输出它不同排列顺序下的情况。{1,2,3}就是[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]</p><p>要解决这种问题同样可以使用递归回溯的方法。Java代码可以表述为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;Integer&gt; cur, <span class="keyword">boolean</span>[] used)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cur.size() == nums.length) ans.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (cur.size() &lt; nums.length) &#123;</span><br><span class="line">    <span class="comment">// 每次从0开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">      cur.add(nums[i]);</span><br><span class="line">      used[i] = <span class="keyword">true</span>; <span class="comment">// 设为使用过</span></span><br><span class="line">      backtrack(cur);</span><br><span class="line">      cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">      used[i] = <span class="keyword">false</span>; <span class="comment">// 设为未使用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips: 如果输入元素有重复的内容，解法跟上题类似，都需要先排序，然后进行如下判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是第一个元素，那么可以直接加入</span></span><br><span class="line"><span class="comment">// 如果这是重复出现的元素，且之前跟它一样的元素未被使用，这说明：之前的元素必定已经加入过一遍了，这些情况必定已经计算过了。</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; A[i] == A[i-<span class="number">1</span>] &amp;&amp;!used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="深度优先-DFS"><a href="#深度优先-DFS" class="headerlink" title="深度优先(DFS)"></a>深度优先(DFS)</h3><p>DFS是一个非常大的题目领域，包括上文的排列、组合，都可以认作DFS。它们可以通过走一条路径，走不通就回退来尝试所有的情况，如果不在乎很高的时间损耗，可以使用DFS。例如：</p><ul><li>括号的配对(左括号的数量影响下一步的决策)</li><li>数独、八皇后(格子里的内容会影响其他各自的选则)</li></ul><p>它的特点在于，会一路尝试到最后，不撞南墙不死心，然后再猪不会退，最后枚举得到正确解。</p><p>例如八皇后问题回溯部分的java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 若尝试到了最后一行，则获得了一个解</span></span><br><span class="line">  <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">    ans++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断这行里面可以放在哪些位置，逐步尝试，并递归</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (valid(row, col)) &#123;</span><br><span class="line">      graph[row][col] = <span class="keyword">true</span>;</span><br><span class="line">      backtrack(row + <span class="number">1</span>);</span><br><span class="line">      graph[row][col] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tips：DFS问题可以通过减枝来优化，即那些显然无解的路径可以避免去走。</p><h3 id="广度优先-BFS"><a href="#广度优先-BFS" class="headerlink" title="广度优先(BFS)"></a>广度优先(BFS)</h3><p>BFS和DFS，我认为本质上没有区别，都是为了遍历全部的情况。但遍历的顺序有所区别，DFS是一条路走到底，而BFS则会一层层地遍历，因此，BFS更适合求层数。</p><p>由于BFS在遍历完成之前会把所有的内容放在栈中，因此，BFS空间复杂度更高。</p><p>一个单向BFS的伪代码可以表示为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> step = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> queue = [start];</span><br><span class="line"><span class="keyword">while</span> queue is not empty:</span><br><span class="line">step++;</span><br><span class="line"><span class="keyword">let</span> size = queue.size();</span><br><span class="line"><span class="keyword">while</span> size-- &gt; <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">let</span> cur = queue.pop();</span><br><span class="line">    new_nodes = expand(cur);</span><br><span class="line">    <span class="keyword">if</span> goal <span class="keyword">in</span> new_nodes <span class="keyword">return</span> step + <span class="number">1</span></span><br><span class="line">    queue.append_all(new_nodes)</span><br><span class="line"><span class="keyword">return</span> not_found</span><br></pre></td></tr></table></figure><p>另外，还有双向BFS，如果明确起始终止的话，从两边开始判定可以显著地减少复杂度，目前先挖个坑。</p><h3 id="划分-Partition"><a href="#划分-Partition" class="headerlink" title="划分(Partition)"></a>划分(Partition)</h3><p>划分也是暴力搜索的一种类型。例如，把一个列表划分为<code>sum</code>相同的子列表。在不用DP的情况下，可以进行暴力枚举+回溯：试着把一个元素放到某个列表里，如果不行，就把它删除。</p><p>为了能够尽可能优化性能，可以按照题目意思进行减枝。</p><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><p><em>2018-3-16</em><br>更新”回溯”部分整理（Search部分的第一行）</p><p><em>2018-3-17</em><br>将”回溯”更名为”组合”，将”置换”更名为”排列”，更新”排列”部分整理(Search部分的第二行)，修改”组合“部分，八皇后问题不能算组合</p><p><em>2018-3-18</em><br>更新”DFS“部分整理(Search部分的第3-5行)，修改”搜索”相关描述</p><p><em>2018-3-21</em><br>更新”BFS”部分整理</p><p><em>2018-3-21</em><br>更新”partition”部分整理，BFS有部分内容暂未完成</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当重复一件事情多次以后，自然而然地就能找到其中的规律。于是我打算按照以下规则来做题，希望能够事半功倍吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>实习准备计划</title>
    <link href="https://infinitexyy.github.io/2019/03/16/intern-prepare/"/>
    <id>https://infinitexyy.github.io/2019/03/16/intern-prepare/</id>
    <published>2019-03-16T08:06:48.000Z</published>
    <updated>2019-03-20T05:08:14.684Z</updated>
    
    <content type="html"><![CDATA[<p>这是本人为应聘Web前端实习生而准备的复习目录<br><a id="more"></a></p><h3 id="为什么要做这个计划"><a href="#为什么要做这个计划" class="headerlink" title="为什么要做这个计划"></a>为什么要做这个计划</h3><p>又到了每年春招的时间。然而后知后觉的我，一直等到2月底的时候，才开始准备。这时候发现周围好多同学都早早就投递了简历_(:з」∠)__。本着进不了也要试一试的心态，我在没怎么准备情况下就投了tx的前端实习生岗，想着自己也做过几个小项目，还是可以说一点的。emmm，然而果不其然被刷掉了，像跨域之类的问题，因为自己平时都是用的proxy、照着readme弄过一两次cors的样子😂，所以根本答不上来什么呀。还有一题，问我list的含义（事后回想应该是问的this），于是瞎答一通，还被嘲讽js基础都不知道为啥面前端。。。😢</p><p>因此呢，为了能<strong>系统地巩固Web前端的知识</strong>（下次能答出更多的问题），现在决定开始复习啦！</p><p>我会将复习的过程记录在这个博客里，一方面是监督自己，一方面也是记录一下心得，分享一下经验吧。。</p><p><strong>如果有什么意见或者建议的话，请务必评论哈！谢谢！</strong></p><h3 id="几个方向"><a href="#几个方向" class="headerlink" title="几个方向"></a>几个方向</h3><p>我计划从以下几个方向开始复习，每个部分，都会有对应的文章博客来记录整理知识点。这就当是个目录吧！</p><ul><li>概念基础<ul><li>JS语言基础</li><li>Html/CSS基础</li><li>浏览器/协议安全</li><li>计算机网络</li></ul></li><li>框架基础<ul><li>React</li><li>Redux</li></ul></li><li>算法与设计<ul><li>刷leetcode吧</li><li>设计模式</li></ul></li><li>其它<ul><li>个人介绍</li><li>项目整理</li></ul></li></ul><h5 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h5><p><img src="mind.png" alt="mind-graph"></p><h3 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h3><p>怎么说呢，虽然很多人急于找实习、找工作，但是我还是更希望能够更加平稳的舒服地去学习新的知识。所以我暂时不会去投很多的简历，可能是精力不够吧，我觉得编程应该是一个慢慢来的、像画画一样的活动，可以停下来，出去走走，晒晒太阳，思考一下我想做出什么，思考一下现在做了些什么。而不是扎在电脑前，固执于某个方法，或者为了快速拿出成果而不眠不休。</p><p>这当然不是说，坚持是不好的。而是在坚持前，应该问自己几个问题：</p><ul><li>我为什么在做这个事情</li><li>这个有必要吗</li><li>有没有更好的办法</li></ul><p>看面经、刷面试题、刷框架基础知识，固然效果显著，但我想慢慢来，慢慢学习基础，并在实践中巩固。</p><p>春天的白玉兰开了，不去看看嘛？</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><strong>目录会更新吗</strong>？</p><p>这个当然。就跟迭代开发一样嘛，后续如果发现有疏漏的点，或者可以有更加清晰的知识体系，都会在此更新。</p><p><strong>这个博客会一直更新下去吗？</strong></p><p>会的！最近为了准备实习，看了许多同龄人的博客，觉得非常有意思，所以会把平时的学到的知识或者想法分享到这里，不只是记录下准备的过程。</p><p><strong>目标的企业是？</strong></p><p>这个先不说了QWQ，(其实也没大考虑好)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本人为应聘Web前端实习生而准备的复习目录&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://infinitexyy.github.io/2019/03/16/my-first-blog/"/>
    <id>https://infinitexyy.github.io/2019/03/16/my-first-blog/</id>
    <published>2019-03-16T05:54:48.000Z</published>
    <updated>2019-03-16T14:28:58.339Z</updated>
    
    <content type="html"><![CDATA[<p>试验一下<code>markdown</code>的渲染效果<br><a id="more"></a></p><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul><li>Reason</li><li><strong>Typescript</strong></li><li>Flow</li><li>Elm</li></ul><hr><h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (temp[i] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      temp[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.values(temp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><blockquote><p>Hi, this is infinitex</p><p>Second line</p></blockquote><h5 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h5><p><a href="http://www.infinitex.cn" target="_blank" rel="noopener">Infinitex.cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;试验一下&lt;code&gt;markdown&lt;/code&gt;的渲染效果&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
