<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> webpack的第二次学习 · InfiniteX</title><meta name="description" content="webpack的第二次学习 - Yiyang Xu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://infinitexyy.github.io/blog/atom.xml" title="InfiniteX"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/blog/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="https://github.com/InfiniteXyy" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">webpack的第二次学习</h1><div class="post-info">2019年4月12日</div><div class="post-content"><p>本文承接于上一篇文章《webpack的第一次学习》，在那篇文章中，通过阅读文档学习了基本的webpack组成与其基本使用方法。这篇文章将尝试写一个简易版本的webpack(参考了<a href="https://www.youtube.com/watch?v=Gc9-7PBqOC8&amp;t=597s" target="_blank" rel="noopener">这个视频</a>)</p>
<a id="more"></a>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>需求目标</li>
<li>组成部分</li>
<li>具体实现</li>
<li>后续目标与重构</li>
</ul>
<h3 id="需求目标"><a href="#需求目标" class="headerlink" title="需求目标"></a>需求目标</h3><p>实现一个js模块打包程序，具有以下功能：</p>
<ul>
<li>输入entry文件，将它与其所依赖的所有内容打包为一个js文件</li>
<li>不为多次依赖同一个文件进行优化</li>
<li>不考虑循环依赖</li>
</ul>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>首先，整理一下这个功能的完成过程。</p>
<ol>
<li>系统读入文件</li>
<li>系统保存代码</li>
<li>系统分析依赖(若有依赖，goto 2)</li>
<li>将所有保存的代码整合输出</li>
</ol>
<p>第一、二步无需多言，可以通过nodejs的fs模块来完成。</p>
<p>第三步可以通过babel的语法分析引擎(@babel/parser)完成。</p>
<p>重点在与第四步。程序如何将多个代码段整合到一起呢？</p>
<p><strong>可能的方法</strong></p>
<ul>
<li>直接拼接，自上而下依次运行所有脚本行<ul>
<li>产生的问题：命名冲突(驳回)</li>
</ul>
</li>
<li>打包为一个个方法闭包，依次运行所有函数<ul>
<li>最终选择！</li>
</ul>
</li>
</ul>
<p>回归一下模块的exports的规则。</p>
<p>module.exports可以设置模块的导出对象，exports是module.exports的一个<strong>引用</strong>。</p>
<p>require可以获得一个模块的module.exports</p>
<p>因此函数可以设计为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code here</span></span><br><span class="line">  <span class="comment">// sample</span></span><br><span class="line">  <span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">"./hello.js"</span>)</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">"world"</span>;</span><br><span class="line">  <span class="built_in">module</span>.exports = hello(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何调用呢，可以设计为递归的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个模块的代码在这里</span></span><br><span class="line"><span class="keyword">const</span> mapping = &#123;</span><br><span class="line">  <span class="string">'entry.js'</span>: &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'second.js'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">1</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'second.js'</span>: &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">module</span>.exports = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载函数，返回某一个模块的exports</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; fn &#125; = mapping[entry];</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line">  <span class="comment">// 将load方法传入(作为require方法)，如果有依赖的话会先去计算依赖</span></span><br><span class="line">  fn(load, <span class="built_in">module</span>, <span class="built_in">module</span>.exports);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">load(<span class="string">'entry.js'</span>);</span><br></pre></td></tr></table></figure>
<p>这么写似乎就可以了。但好像哪里不大对？没错，这样的话函数就是对外可见的了，不是特别好。最后的解决方法是写一个超大的函数，把所有的子模块作为参数传入，然后函数在内部进行，另外也需要把整个应用作为字符串导出。</p>
<p>这里可以实现一个bundle函数(参照了网上的代码)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> modules = <span class="string">''</span>;</span><br><span class="line">  graph.forEach(<span class="function"><span class="params">mod</span> =&gt;</span> &#123;</span><br><span class="line">    modules += <span class="string">`<span class="subst">$&#123;mod.id&#125;</span>: [</span></span><br><span class="line"><span class="string">      function (require, module, exports) &#123;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;mod.code&#125;</span></span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(mod.mapping)&#125;</span>,</span></span><br><span class="line"><span class="string">    ],`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`(function(modules) &#123;</span></span><br><span class="line"><span class="string">    function require(id) &#123;</span></span><br><span class="line"><span class="string">      const [fn, mapping] = modules[id];</span></span><br><span class="line"><span class="string">      function localRequire(name) &#123;</span></span><br><span class="line"><span class="string">        return require(mapping[name]);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      const module = &#123; exports: &#123;&#125; &#125;;</span></span><br><span class="line"><span class="string">      fn(localRequire, module, module.exports);</span></span><br><span class="line"><span class="string">      return module.exports;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    require(0);</span></span><br><span class="line"><span class="string">  &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后续目标与重构"><a href="#后续目标与重构" class="headerlink" title="后续目标与重构"></a>后续目标与重构</h3><p>还记得webpack的几大重要组件吗？除了入口出口以外，还有丰富的插件和loader。</p>
<p>另外，目前这个简易版的pack对于require必须包含后缀名，同时也只能处理js文件，下一章来尝试一下不同的loader把。</p>
</div></article></div></main><footer><div class="paginator"><a href="/blog/2019/04/17/leetcode-bs/" class="prev">上一篇</a><a href="/blog/2019/04/06/webpack/" class="next">下一篇</a></div><div id="gitalk-container"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
    clientID: 'b6e1047fa622a6e8f554',
    clientSecret: '37f6dc0c4c6ed7892e12f214b2ea319edb968f9e',
    repo: 'InfiniteXyy.github.io',
    owner: 'InfiniteXyy',
    admin: 'InfiniteXyy',
    id: window.location.pathname,
    distractionFreeMode: false  // Facebook-like distraction free mode
})
gitalk.render('gitalk-container')</script><div class="copyright"><p>© 2019 <a href="https://infinitexyy.github.io/blog">Yiyang Xu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>